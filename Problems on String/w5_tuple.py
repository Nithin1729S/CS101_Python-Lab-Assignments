# -*- coding: utf-8 -*-
"""W5 Tuple.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hoUef0Dn8cq8M5lk7YXovafpjG_Ninit

**Tuple**: Python Tuples are like a list. It can hold a sequence of items. The difference is that it is immutable.

creating a tuple:
"""

t = (1,)
type(t)

t1 = tuple()
type(t1)

t3 = ("abc",)
type(t3)

t4 = (12,)
type(t4)

"""tuple works without paranthesis"""

t5 = 12,
type(t5)

t7 = 'abc', 1, -6, 2.8
type(t7)

# tuple() constructor converts another construct into a python tuple
list1 = [1,2,3]
tuple([1,2,3])

str1 = "String"
tuple(str1)

set1 = {2,6,3,4,4.5, 'A',2}
l=[1,2,3,1,23]
l=set(l)
l

set1

"""nested tuples"""

t6 = (1,(2,3,4), [1,'a',-6], 'a')
t6[2][0]

t6

a_tup = tuple('abc',)

a_tup

#tuple expected at most 1 argument, got 3
a_tup = tuple('abc','def','ghi')

a_tuple = tuple(['abc','def','ghi'])

a_tuple

"""*tuple* indexing"""

tp1 = (1, 4, 6, 5, 4, 2)

#tp1[3]
tp1[-5]

tp1[::-1]

tp1

tp1[1:4]

tp1[:-2]

tp1[:]

t6

#len(t6)
len(t6[1])

t6[1][2]

t6[2][2]

"""how to change the element in a tuple"""

t6

t6[0]

t6[0] = 5

t6[1]

t6[1][2] = 'a'

type(t6[1])

t6[2]

type(t6[2])

t6[2][0] = 1j

t6[2]

t6

t5

"""tuple deletion"""

del t5

t5

"""tuple count"""

tp3 = (4, 5, 7, 8, 2, '4', 7, 8, 7)

tp3.count(7)

"""tuple index"""

tp3.index(7)

"""**Tuple Operations**:

membership operator

Concatenation

Logical

Identity
"""

9 not in tp3

# membership
9 in tp3

#concatenation(Other arithmetic operations do not apply on a tuple.)
t6 + t5

#logical (All the logical operators (like >,>=,..) can be applied on a tuple).
(1,9,3)>(4,5,6,0)

(1,2)==('1','2')

(1,2) == (1,2)

# Identity ( ‘is’ and ‘is not’ operators)
a=(1,2)
(1,2) is a

a=(1,2,3)
print(id(a))
print(id(a[0]))
print(id(a[1]))
print(id(a[2]))

a_list = [1,2,3]
print(id(a_list))
print(id(a_list[0]))
print(id(a_list[1]))
print(id(a_list[2]))

"""**Built-in functions in Tuple**

tuple(), len(), max(), min(), sum(), sorted(), any(), and all()
"""

my_tuple = (1,2,3,[4,5])

len(my_tuple) # list counts as 1

#max() returns the item with the maximum value
#we can not apply this method on my_tuple, because integers can not be compared to a list
max(my_tuple)

max(('hi', 9))

a = (3, 1, 0, 4, -3)

max(a)

min(a)

b = ('hi', 'Hi',' all')

max(b)

min(b)

ord(" ")

sum(a)

tp3

sum(tp3)

"""**any()**: If even one item in the tuple has a boolean value of True, then this function returns True. Otherwise, it returns False"""

any(('a', '0', ' ')) # a string '0' has a boolean value of True

any((0, 0>1,'', ' '))

any(('', 0, ''))

"""**all()**: Unlike any(), all() returns True only if all items have boolean value of True. Otherwise, it returns False"""

all(('1', 1, ''))

all(('1', 1, ' '))

a

sorted(a) # returns a tuple with elements sorted

reversed(a)

for i in reversed(a_tuple):
  print(i)

for i in enumerate(a_tuple):
  print(i)

for i,item in enumerate(a_tuple):
  print(f"Element at {i} is {item}")

tp3

sorted(tp3)

"""**Iterating on a Python Tuple**"""

for i in (1,3,2,['a','5']):
  print(i)

b_tuple=100,200,300,400,

for item in b_tuple:
  print(item)

for i,item in enumerate(b_tuple):
  print(i,item)

"""**Tuple Comprehension**"""

tuple((i, item) for i,item in enumerate(b_tuple))

[(i, item) for i,item in enumerate(b_tuple)]

# create a list of 2-tuples like (number, square)
[(x, x**2) for x in range(6)]

# the tuple must be parenthesized, otherwise an error is raised
[i, item for i,item in enumerate(b_tuple)]

"""**Iterating Dictionaries with Tuples**"""

source_data = {"fish": "gold", "monkey": "brown"}

multiple_elements_dict_1 = tuple(source_data)

multiple_elements_dict_1

multiple_elements_dict_2 = tuple(source_data.items())

multiple_elements_dict_2

"""**zip()**

The zip() function returns a zip object, which is an iterator of tuples where the first item in each passed iterator is paired together, and then the second item in each passed iterator are paired together etc.

If the passed iterators have different lengths, the iterator with the least items decides the length of the new iterator.
"""

a_tuple=10,20,30,40,
b_tuple=100,200,300,400,
for i in zip(a_tuple, b_tuple):
  print(i)

c_tuple='one','two', 'three', 'four'
ab_list=[i for i in zip(a_tuple,b_tuple)]
abc_list=[i for i in zip(a_tuple, b_tuple, c_tuple)]

ab_list

abc_list

'''If the passed iterators have different lengths, 
the iterator with the least items decides the length of the new iterator.'''
a = ("John", "Charles", "Mike")
b = ("Jenny", "Christy", "Monica", "Vicky")

x = zip(a, b)

print(tuple(x))

"""map():"""

a = input().split()

a

type(a[0])

b = list(map(int, input().split()))

b

type(b[0])

c = set(map(float, input().split()))

c



"""**Lists vs. Tuples**

---

Mutable; immutable

support mutable sequence ops; do not support mutable sequence ops

homogeneous elements; heterogeneous elements

values are modified; values are constant

Larger in memory ; Smaller in memory

Access on Lists is Slower than accesses on Tuples
"""